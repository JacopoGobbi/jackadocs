package net.jackadull.jackadocs.docs.readme

import net.jackadull.jackadocs.structure.{Chapter, RootChapter}

import scala.xml.NodeSeq

object Ch3_UsageExample extends Chapter {
  def title = "Usage Example"

  def contents(root:RootChapter):NodeSeq =
<p>
  As described, there is no special magic in using Jackadocs.
  Because there are many ways to use the tools presented by the Jackadocs library, the best introduction is an example.
  The reader can then make up his or her own way of preference of using Jackadocs.
</p>
<p>
  The sub-module and code that generates this text serves as the example.
  It can be found in the <a href="https://github.com/jackadull/jackadocs/tree/master/docs-generator"><tt>docs-generator</tt></a> subfolder of the <tt>jackadocs</tt> project.
  In it, you will find:
</p>
<ul>
  <li>A separate <tt>pom.xml</tt> for the documentation-generating project.</li>
  <li>Scala souce code under <tt>src/main/scala</tt> that contains all the data for generating this documentation.</li>
</ul>

  override def subChapters:Seq[Chapter] = Seq(
    Chapter("How to Re-Generate this Documentation",
<p>
  The documentation of Jackadocs (i.e., the <tt>README.md</tt> in the <tt>jackadocs</tt> project root folder) is (re-)generated by choosing <tt>docs-generator</tt> as the current working directory and executing:
</p>
<pre><code class="language-bash">
mvn clean compile exec:java
</code></pre>
<p>
  Maven will then clean up the target folder, compile the project, and run the main class.
  The details of this execution are defined in <tt>docs-generator/pom.xml</tt>, in the configuration of the <tt>exec-maven-plugin</tt>:
  As can bee seen there, the main class (i.e., the class that contains the <tt>main</tt> method) is <tt>net.jackadull.jackadocs.docs.Main</tt>.
  Also, the first (and only) command-line argument for the execution is configured as <tt>${{project.basedir}}</tt>.
  This means that the path to the <tt>docs-generator</tt> project folder will be passed to the <tt>main</tt> method.
</p>,
      subChapters = Seq(
Chapter("Automation in the Main Project",
<p>
  The process of re-generating the documentation has been automated:
  When calling <tt>mvn install</tt> on the main module, the Maven Exec plugin is used to call <tt>mvn clean compile exec:java</tt> inside the <tt>docs-generator</tt> folder.
  You can see an example of this utility in <a href="https://github.com/jackadull/jackadocs/blob/release/latest/pom.xml">the main POM file of Jackadocs</a>.
  (Look for <tt>exec-maven-plugin</tt>, and the configured execution <tt>re-generate-docs</tt>.)
</p>
<p>
  The main POM also contains another option:
  When the Maven profile <tt>jackadull-release</tt> is active, then the option <tt>-V</tt> is added to the command-line parameters of the <tt>docs-generator</tt> run.
  This does not re-generate the documentaton, but just verifies that the current version has all the latest information.
  More on that further below.
</p>
)
      )
    ),
    Chapter("The Main Class",
<p>
  The source code of the main class can be found <a href="https://github.com/jackadull/jackadocs/blob/kickoff/docs-generator/src/main/scala/net/jackadull/jackadocs/docs/Main.scala">here</a>.
  As can be seen, it inherits from <tt>JackadocsMain</tt> and <tt>App</tt>.
  <tt>JackadocsMain</tt> is really not a requirement; it can be extended optionally for some utility value.
  Its source code is quite short, so you may want to look it up.
</p>
<p>
  Here is what it does:
</p>
<ul>
  <li>
    <p>
      It creates a <tt>Jackadocs</tt> instance, stored in the variable <tt>jackadocs</tt>.
      This class contains the main functions used for generating the documentation, and some other things.
    </p>
    <p>
      The <tt>Jackadocs</tt> factory method receives the command-line arguments.
      The most important (and required) argument is the path to the <tt>docs-generator</tt> folder.
    </p>
    <p>
      The other optional argument is <tt>-V</tt>.
      When specified, files will not be overwritten, but their contents will only be verified.
      When <tt>-V</tt> is specified and one of the documentation files is not exactly as it <i>would</i> be written, the program fails.
    </p>
  </li>
  <li>
    <p>
      It validates that the dependency to the main project has the expected version.
      <tt>JackadocsMain</tt> reads the POM file of the main project and extracts the artifact version.
      It then compares this version with the version included in the <tt>docs-generator</tt> project.
      Should the two not match, the program exits with an error.
    </p>
    <p>
      This can happen quite frequently, when updating the version of the main POM, but forgetting to update it in <tt>docs-generator</tt> as well.
    </p>
  </li>
</ul>
<p>
  The <tt>Main</tt> object of Jackadocs' <tt>docs-generator</tt> also does the following:
</p>
<ul>
  <li>
    <p>Generate the <tt>README.md</tt> file:</p>
<pre><code class="language-scala">
jackadocs generateAt s"$projectDir/README.md" markdownFor ReadmeRoot
</code></pre>
    <p>
      Tells Jackadocs to generate the Markdown for <tt>ReadmeRoot</tt> and write it into <tt>README.md</tt>, relative to the project base directory that was passed in as a command-line argument.
    </p>
    <p>
      <tt>ReadmeRoot</tt> can be found <a href="https://github.com/jackadull/jackadocs/blob/master/docs-generator/src/main/scala/net/jackadull/jackadocs/docs/ReadmeRoot.scala">here</a>.
      The contents of this object follow the chapter structure, which gets described below.
    </p>
  </li>
  <li>
    <p>Define the minimum set of methods required by <tt>JackadocsMain</tt>:</p>
    <ul>
      <li>
<pre><code class="language-scala">
def organizationName = "jackadull"
</code></pre>
        <p>This is the name of the organization, as it usually appears in URLs of services like GitHub, Travis-CI etc.</p>
      </li>
      <li>
<pre><code class="language-scala">
def projectDir = ".."
</code></pre>
        <p>The path to the main project, relative to <tt>docs-generator</tt>.</p>
      </li>
      <li>
<pre><code class="language-scala">
def projectInfo = new JackadocsInfo with JackadocsProjectInfo
</code></pre>
        <p>
          Makes the Maven artifact data (group/artifact ID and version) accessible to <tt>JackadocsMain</tt>.
          This is used for a couple of features.
        </p>
        <p>
          Jackadocs requires the artifact data in form of an instance of <tt>JackadocsProjectInfo</tt>.
          Since the main project usually does not have a Maven dependency on Jackadocs, that type is not available from inside the main project.
          Therefore, Jackadull projects usually define a trait named <i>[Project name]</i><tt>Info</tt> that defines the methods <tt>artifactID</tt>, <tt>groupID</tt> and <tt>version</tt>.
          Those are filled in by Maven during the compilation phase.
          This is for giving the runtime information about the actual dependency used.
        </p>
        <p>
          The construct of <tt>new JackadocsInfo with JackadocsProjectInfo</tt> creates a new instance that satisifies the <tt>JackadocsProjectInfo</tt> trait.
        </p>
      </li>
      <li>
<pre><code class="language-scala">
def sourceRepoProvider = "github"
</code></pre>
        <p>Used for GitHub readme badges that require the source repo provider as part of the URL.</p>
      </li>
    </ul>
  </li>
</ul>
<p>
  When you take a look at
    <a href="https://github.com/jackadull/jackadocs/blob/release/latest/src/main/scala/net/jackadull/jackadocs/execution/JackadocsMain.scala"><tt>JackadocsMain</tt></a>
    and its super type
    <a href="https://github.com/jackadull/jackadocs/blob/release/latest/src/main/scala/net/jackadull/jackadocs/structure/DocsMetaData.scala"><tt>DocsMetaData</tt></a>,
    you will find many more properties with reasonable default implementations that can be overridden when necessary.
</p>
    )
  )
}
